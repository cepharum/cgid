/**
 * HTTP Parser
 *
 * @author Thomas Urban <thomas.urban@cepharum.de>
 * @license GPLv3
 * @package cgid
 */

/**
 * HTTP Parser
 *
 * Feedable parser looking for end-of-head marker in a data stream considered
 * to contain single HTTP message. On meeting end-of-head marker all data
 * preceding it is parsed into object using ASCII encoding. All succeeding data
 * is collected in a separate buffer instance.
 *
 * @param {Boolean} blnRelaxed true to support LFLF as a valid end-of-head marker, too
 * @param {Function} fncOnHeadersComplete callback invoked after head data has
 *                   been parsed, called with parsed header as first argument in
 *                   context of parser instance
 */

function HttpParser( blnRelaxed, fncOnHeadersComplete )
{
	// explicit reference on current instance
	var that = this;

	// cached set of message's headers set on parsing completely collected head data
	var headers = null;

	// buffer instances collecting raw head/body data
	var rawHead = new Buffer( 0 );
	var rawBody = new Buffer( 0 );

	// state of parser used to detect end-of-head marker
	var state = 0;

	// adjustable collector method
	var collect = function( chunk )
	{
		rawHead = Buffer.concat( [ rawHead, chunk ] );
	};

	// method called on having collected all head data to parse it for headers
	function onHeadersComplete()
	{
		headers = {};

		rawHead.toString( "ascii" )
			.split( blnRelaxed ? /\r?\n(?!\s)/ : /\r\n(?!\s)/ )
			.forEach( function( line, index )
			{
				var p = line.match( /^(\S+)\s*:\s*(.*)$/ );
				if ( p )
				{
					var name = p[1].toLowerCase( );

					var exist = headers[name];
					switch ( typeof exist )
					{
						case "undefined" :
							headers[name] = p[2];
							break;
						case "string" :
							headers[name] = [exist, p[2]];
							break;
						case "object" :
							exist.push( p[2] );
							break;
					}
				}
			} );


		if ( typeof fncOnHeadersComplete == "function" )
		{
			fncOnHeadersComplete.call( that, headers );
		}
	}

	// ------------------------------------------------------------------------

	/**
	 * Retrieves raw head as collected previously.
	 *
	 * @return {Buffer} raw head data
	 */

	this.rawHead = function()
	{
		return rawHead;
	};

	/**
	 * Retrieves raw body as collected previously.
	 *
	 * @return {Buffer} raw body data
	 */

	this.rawBody = function()
	{
		return rawBody;
	};

	/**
	 * Indicates whether head has been collected and parsed completely or not.
	 *
	 * @return {Boolean} true on having collected and parsed head previously
	 */

	this.headersComplete = function()
	{
		return state < 0;
	};

	/**
	 * Retrieves parsed headers of fed HTTP message.
	 *
	 * @return {Object} parsed headers of HTTP message, empty on called before
	 *                  having collected all head data
	 */

	this.headers = function()
	{
		return headers || {};
	};

	/**
	 * Provides another chunk of data to be collected.
	 *
	 * This method is intended to be invoked on a data event emitted on a
	 * ReadableStream.
	 *
	 * @parameter chunk {Buffer} another chunk of HTTP message's data to collect
	 */

	this.feed = function( chunk )
	{
		if ( state >= 0 )
		{
			for ( var i = 0; i < chunk.length; i++ )
			{
				var ch = chunk[i];

				switch ( state )
				{
					case 0 :
						if ( ch == 13 )
						{
							state = 1;
						}
						else if ( blnRelaxed && ch == 10 )
						{
							state = 3;
						}
						break;

					case 1 :
						state = ( ch == 10 ) ? 2 : 0;
						break;

					case 2 :
						state = ( ch == 13 ) ? 3 : 0;
						break;

					case 3 :
						if ( ch == 10 )
						{
							// met end of header

							// collect end of header contained in current chunk
							rawHead = Buffer.concat( [ rawHead, chunk.slice( 0, i + 1 ) ] );

							// initialize body data buffer with data succeeding met end of header
							rawBody = chunk.slice( i + 1 );

							// process header as it's completely available now
							onHeadersComplete();

							// adjust collector to work on that body data buffer now
							collect = function( chunk )
							{
								rawBody = Buffer.concat( [ rawBody, chunk ] );
							};

							// disable detection of end-of-header marker
							state = -1;

							return;
						}
						else
						{
							state = 0;
						}
						break;
				}
			}
		}

		collect( chunk );
	};
}

// ----------------------------------------------------------------------------

/**
 * Creates new instance of HttpParser prepared to collect and parse single
 * HTTP message.
 *
 * @param {Boolean} blnRelaxed true to support LFLF as a valid end-of-head marker, too
 * @param {Function} fncOnHeadersComplete callback invoked after head data has
 *                   been parsed, called with parsed header as first argument in
 *                   context of parser instance
 * @return {HttpParser} created instance
 */

module.exports.createParser = function( blnRelaxed, fncOnHeadersComplete )
{
	return new HttpParser( blnRelaxed, fncOnHeadersComplete );
};
