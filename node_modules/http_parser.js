function HttpParser( blnRelaxed, fncOnHeadersComplete )
{
	var that = this;

	var headers = null;

	var rawHead = new Buffer( 0 );
	var rawBody = new Buffer( 0 );

	var state = 0;


	function onHeadersComplete()
	{
		headers = {};

		rawHead.toString( "ascii" )
			.substr( 0, splitPoint )
			.split( blnRelaxed ? /\r?\n(?!\s)/ : /\r\n(?!\s)/ )
			.forEach( function( line, index )
			{
				var p = line.match( /^(\S+)\s*:\s*(.*)$/ );
				if ( p )
				{
					var name = p[1].toLowerCase( );

					var exist = headers[name];
					switch ( typeof exist )
					{
						case "undefined" :
							headers[name] = p[2];
							break;
						case "string" :
							headers[name] = [exist, p[2]];
							break;
						case "object" :
							exist.push( p[2] );
							break;
					}
				}
			} );


		if ( typeof fncOnHeadersComplete == "function" )
		{
			fncOnHeadersComplete.call( that, headers );
		}
	}

	this.rawHead = function()
	{
		return rawHead;
	};

	this.rawBody = function()
	{
		return rawBody;
	};

	this.headersComplete = function()
	{
		return state < 0;
	};

	this.headers = function()
	{
		return headers || {};
	};

	var collect = function( chunk )
	{
		rawHead = Buffer.concat( [ rawHead, chunk ] );
	};

	this.feed = function( chunk )
	{
		if ( state >= 0 )
		{
			for ( var i = 0; i < chunk.length; i++ )
			{
				var ch = chunk[i];

				switch ( state )
				{
					case 0 :
						if ( ch == "\r" )
						{
							state = 1;
						}
						else if ( blnRelaxed && ch == "\n" )
						{
							state = 3;
						}
						break;

					case 1 :
						state = ( ch == "\n" ) ? 2 : 0;
						break;

					case 2 :
						state = ( ch == "\r" ) ? 3 : 0;
						break;

					case 3 :
						if ( ch == "\n" )
						{
							// met end of header

							// collect end of header contained in current chunk
							rawHead = Buffer.concat( [ rawHead, chunk.slice( 0, i + 1 ) ] );

							// initialize body data buffer with data succeeding met end of header
							rawBody = chunk.slice( i + 1 );

							// process header as it's completely available now
							onHeadersComplete();

							// adjust collector to work on that body data buffer now
							collect = function( chunk )
							{
								rawBody = Buffer.concat( [ rawBody, chunk ] );
							};

							// disable detection of end-of-header marker
							state = -1;

							return;
						}
						else
						{
							state = 0;
						}
						break;
				}
			}
		}

		collect( chunk );
	};
}

module.exports.createParser = function( blnRelaxed, fncOnHeadersComplete )
{
	return new HttpParser( blnRelaxed, fncOnHeadersComplete );
};
